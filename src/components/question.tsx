import { useEffect, useState } from "react";
import styles from "./style.module.css";
import { Players } from "./players";

interface Props {
  onClick: () => void;
  category: string;
  question: string;
  difficulty: string;
  background: string;
}

export const Question = ({
  onClick,
  category,
  question,
  difficulty,
  background,
}: Props) => {
  const [currentRecording, setCurrentRecording] = useState(1);
  const [timer, setTimer] = useState(30);
  const [timerWidth, setTimerWidth] = useState(100); // Width in percentage
  const [sequenceFinished, setSequenceFinished] = useState(false);
  const [finished, setFinished] = useState(false);
  const [correctAnswer, setCorrectAnswer] = useState(-1);
  const [isBlinking, setIsBlinking] = useState(false);

  const recordings = [
    `/audios/${category}/${difficulty}/${question}_true1.mp3`,
    `/audios/${category}/${difficulty}/${question}_true2.mp3`,
    `/audios/${category}/${difficulty}/${question}_true3.mp3`,
    `/audios/${category}/${difficulty}/${question}_fake.mp3`,
  ];

  useEffect(() => {
    const playSequence = async () => {
      // Shuffle the recordings array
      const shuffledRecordings = recordings.sort(() => Math.random() - 0.5);
      setCorrectAnswer(
        shuffledRecordings.findIndex((recording) =>
          recording.endsWith("_fake.mp3")
        )
      );
      for (let i = 0; i < shuffledRecordings.length; i++) {
        const audio = new Audio(shuffledRecordings[i]);
        setCurrentRecording(i + 1);
        await new Promise((resolve) => {
          audio.onended = resolve;
          audio.play();
        });
        await new Promise((resolve) => setTimeout(resolve, 2000)); // Pause between recordings
      }
      setCurrentRecording(0);
      setSequenceFinished(true);
    };

    playSequence();
    return () => {
      setCurrentRecording(0);
    };
  }, []);

  useEffect(() => {
    let interval: string | number | NodeJS.Timeout | undefined;
    if (sequenceFinished) {
      interval = setInterval(() => {
        setTimer((prevTimer) => {
          if (prevTimer > 0) {
            const newWidth = ((prevTimer - 1) / 30) * 100;
            setTimerWidth(newWidth);
            return prevTimer - 1;
          }
          clearInterval(interval);
          handleCorrect();
          return 0;
        });
      }, 1000);
    }

    return () => clearInterval(interval);
  }, [sequenceFinished]);

  const handleCorrect = () => {
    setIsBlinking(true);
    setTimeout(() => {
      setIsBlinking(false);
      setFinished(true);
    }, 2000); // Blink for 2 seconds
  };

  return (
    <>
      <div className={styles.question} style={{ background }}>
        <div className={styles.question__top}>
          <h2>
            Question for {difficulty}: which is a fake recording generated by
            AI?
          </h2>
          {finished && <XIcon onClick={onClick} />}
        </div>
        <div className={styles.question__content}>
          <div className={styles.question__content__top}>
            <div>
              <img
                src={`/audios/${category}/${difficulty}/${question}.png`}
                alt="trump"
              />
            </div>
            <div className={styles.question__content__top__text}>
              {currentRecording > 0 ? (
                <>
                  {<h3>Recording {currentRecording} is playing</h3>}
                  <div className={styles.typing}>
                    <span></span>
                    <span></span>
                    <span></span>
                  </div>
                </>
              ) : (
                <h3>Select the fake recording</h3>
              )}
            </div>
          </div>
          <div className={styles.question__choices}>
            <ul className={styles.question__choices__list}>
              {[1, 2, 3, 4].map((recordingNumber) => (
                <li
                  key={recordingNumber}
                  className={`${styles.question__choices__item} ${
                    currentRecording === recordingNumber ? styles.active : ""
                  }${
                    isBlinking && recordingNumber - 1 === correctAnswer
                      ? styles.blink
                      : ""
                  }`}
                >
                  Recording {recordingNumber}
                </li>
              ))}
            </ul>
          </div>
          <div
            className={styles.timerBar}
            style={{ width: `${timerWidth}%` }}
          ></div>
        </div>
      </div>
    </>
  );
};

export const XIcon = ({ onClick }: { onClick?: () => void }) => {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 10 11"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      onClick={onClick}
    >
      <path
        d="M8.99996 9.49996L5 5.5M5 5.5L1 1.5M5 5.5L9 1.5M5 5.5L1 9.5"
        stroke="white"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
};
